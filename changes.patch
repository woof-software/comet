diff --git a/hardhat.config.ts b/hardhat.config.ts
index ce90a800..94ab47c4 100644
--- a/hardhat.config.ts
+++ b/hardhat.config.ts
@@ -64,7 +64,7 @@ const {
   _TENDERLY_KEY_RONIN,
   _TENDERLY_KEY_POLYGON,
   _TENDERLY_KEY_OPTIMISM,
-  _TENDERLY_KEY_LINEA,
+  LINEA_QUICKNODE_KEY,
   MNEMONIC = 'myth like woof scare over problem client lizard pioneer submit female collect',
   REPORT_GAS = 'false',
   NETWORK_PROVIDER = '',
@@ -95,7 +95,7 @@ export function requireEnv(varName, msg?: string): string {
   'SNOWTRACE_KEY',
   'INFURA_KEY',
   'ANKR_KEY',
-  'UNICHAIN_QUICKNODE_KEY'
+  'UNICHAIN_QUICKNODE_KEY',
 ].map((v) => requireEnv(v));
 
 // Networks
@@ -144,7 +144,7 @@ export const networkConfigs: NetworkConfig[] = [
   {
     network: 'optimism',
     chainId: 10,
-    url: `https://optimism.gateway.tenderly.co/${_TENDERLY_KEY_OPTIMISM}`,
+    url: `https://rpc.ankr.com/optimism/${ANKR_KEY}`,
   },
   {
     network: 'mantle',
@@ -163,7 +163,8 @@ export const networkConfigs: NetworkConfig[] = [
     network: 'linea',
     chainId: 59144,
     //url: `https://rpc.ankr.com/linea/${ANKR_KEY}`,
-    url: `https://linea.gateway.tenderly.co/${_TENDERLY_KEY_LINEA}`
+    //url: `https://linea.gateway.tenderly.co/${_TENDERLY_KEY_LINEA}`
+    url: `https://omniscient-hardworking-gas.linea-mainnet.quiknode.pro/${LINEA_QUICKNODE_KEY}/`,
   },
   {
     network: 'base',
diff --git a/plugins/import/import.ts b/plugins/import/import.ts
index 925c0a9f..349cbe55 100644
--- a/plugins/import/import.ts
+++ b/plugins/import/import.ts
@@ -491,7 +491,7 @@ export async function loadEtherscanContract(network: string, address: string) {
   const contractFQN = `${contractPath}:${contract}`;
 
   let contractCreationCode = await getContractCreationCode(networkName, address);
-  if (constructorArgs.length > 0 && contractCreationCode.endsWith(constructorArgs)) {
+  if (constructorArgs && constructorArgs.length > 0 && contractCreationCode.endsWith(constructorArgs)) {
     contractCreationCode = contractCreationCode.slice(0, -constructorArgs.length);
   }
 
diff --git a/scenario/LiquidationScenario.ts b/scenario/LiquidationScenario.ts
index 5505ec09..2abd8991 100644
--- a/scenario/LiquidationScenario.ts
+++ b/scenario/LiquidationScenario.ts
@@ -176,13 +176,12 @@ scenario(
     const timeBeforeLiquidation = await timeUntilUnderwater({
       comet,
       actor: albert,
-      fudgeFactor: config.liquidationBot.scenario.fudgeFactorLong // 1 hour past when position is underwater
+      fudgeFactor: config.liquidationBot.scenario.fudgeFactorLong
     });
 
-    while(!(await comet.isLiquidatable(albert.address))) {
-      await comet.accrueAccount(albert.address);
-      await world.increaseTime(timeBeforeLiquidation);
-    }
+    
+    await world.increaseTime(timeBeforeLiquidation);
+    await comet.accrueAccount(albert.address);
 
     const lp0 = await comet.liquidatorPoints(betty.address);
 
@@ -334,4 +333,234 @@ scenario(
     const finalReserves = await comet.getCollateralReserves(asset0Address);
     expect(finalReserves).to.equal(reserves.sub(withdrawAmount));
   }
+);
+
+scenario(
+  'Comet#liquidation > liquidates position with all collateral types',
+  {
+    filter: async (ctx) => !matchesDeployment(ctx, [{ network: 'hardhat', deployment: 'dai' }, { network: 'sepolia', deployment: 'weth' }, { network: 'unichain', deployment: 'usdc' }, { network: 'base', deployment: 'usds' }, { network: 'base', deployment: 'usdbc' }]),
+    tokenBalances: async (ctx) => ({
+      $comet: {
+        $base: getConfigForScenario(ctx).liquidation.base.standard
+      }
+    }),
+    cometBalances: async (ctx) => ({
+      albert: {
+        $base: -getConfigForScenario(ctx).liquidation.base.standard,
+        $asset0: defactor(getConfigForScenario(ctx).liquidation.asset.standard),
+        $asset1: defactor(getConfigForScenario(ctx).liquidation.asset.small),
+        $asset2: defactor(getConfigForScenario(ctx).liquidation.asset.tiny)
+      },
+      betty: { $base: getConfigForScenario(ctx).liquidation.base.standard }
+    }),
+  },
+  async ({ comet, actors }, context, world) => {
+    const config = getConfigForScenario(context);
+    const { albert, betty } = actors;
+    const numAssets = await comet.numAssets();
+
+    const timeBeforeLiquidation = await timeUntilUnderwater({
+      comet,
+      actor: albert,
+      fudgeFactor: config.liquidationBot.scenario.fudgeFactorLong
+    });
+    
+    await world.increaseTime(timeBeforeLiquidation);
+    await comet.accrueAccount(albert.address);
+
+    const lp0 = await comet.liquidatorPoints(betty.address);
+
+    await betty.absorb({ absorber: betty.address, accounts: [albert.address] });
+
+    const lp1 = await comet.liquidatorPoints(betty.address);
+
+    expect(lp1.numAbsorbs).to.eq(lp0.numAbsorbs + 1);
+    expect(lp1.numAbsorbed.toNumber()).to.eq(lp0.numAbsorbed.toNumber() + 1);
+
+    for (let i = 0; i < numAssets; i++) {
+      const { asset } = await comet.getAssetInfo(i);
+      expect(await comet.collateralBalanceOf(albert.address, asset)).to.eq(0);
+    }
+
+    const baseBalance = await albert.getCometBaseBalance();
+    expect(Number(baseBalance)).to.be.greaterThanOrEqual(0);
+
+    expect((await comet.userBasic(albert.address)).assetsIn).to.eq(0);
+  }
+);
+
+scenario(
+  'Comet#liquidation > debt covered with each collateral type separately',
+  {
+    tokenBalances: async (ctx) => ({
+      $comet: {
+        $base: getConfigForScenario(ctx).liquidation.base.standard
+      }
+    }),
+    cometBalances: async (ctx) => ({
+      albert: {
+        $asset0: getConfigForScenario(ctx).liquidation.asset.standard
+      },
+      betty: { $base: getConfigForScenario(ctx).liquidation.base.standard }
+    }),
+  },
+  async ({ comet, actors }, context, world) => {
+    const config = getConfigForScenario(context);
+    const { albert, betty } = actors;
+    const baseToken = await comet.baseToken();
+    const { asset: collateralAsset0 } = await comet.getAssetInfo(0);
+
+    const { borrowCollateralFactor, priceFeed, scale } = await comet.getAssetInfo(0);
+    const userCollateral = await comet.collateralBalanceOf(albert.address, collateralAsset0);
+    const price = await comet.getPrice(priceFeed);
+    const factorScale = await comet.factorScale();
+    const priceScale = await comet.priceScale();
+    const baseScale = await comet.baseScale();
+
+    const collateralValue = userCollateral.mul(price).div(scale);
+    const borrowCapacity = collateralValue.mul(borrowCollateralFactor).mul(baseScale).div(factorScale).div(priceScale);
+    const borrowAmount = borrowCapacity.mul(config.liquidationBot.scenario.borrowCapacityUtilizationHigh).div(100n);
+
+    await albert.withdrawAsset({
+      asset: baseToken,
+      amount: borrowAmount
+    });
+
+    const timeBeforeLiquidation = await timeUntilUnderwater({
+      comet,
+      actor: albert,
+      fudgeFactor: config.liquidationBot.scenario.fudgeFactorShort
+    });
+
+    while(!(await comet.isLiquidatable(albert.address))) {
+      await comet.accrueAccount(albert.address);
+      await world.increaseTime(timeBeforeLiquidation);
+    }
+
+    const lp0 = await comet.liquidatorPoints(betty.address);
+
+    await betty.absorb({ absorber: betty.address, accounts: [albert.address] });
+
+    const lp1 = await comet.liquidatorPoints(betty.address);
+
+    expect(lp1.numAbsorbs).to.eq(lp0.numAbsorbs + 1);
+    expect(await comet.collateralBalanceOf(albert.address, collateralAsset0)).to.eq(0);
+    expect(await comet.isLiquidatable(albert.address)).to.be.false;
+  }
+);
+
+scenario(
+  'Comet#liquidation > small position liquidation',
+  {
+    filter: async (ctx) => !matchesDeployment(ctx, [{ network: 'hardhat', deployment: 'dai' }]),
+    tokenBalances: async (ctx) => ({
+      $comet: { $base: getConfigForScenario(ctx).liquidation.base.standard * 10n }
+    }),
+    cometBalances: async (ctx) => ({
+      albert: {
+        $base: -getConfigForScenario(ctx).liquidation.base.standard * 10n,
+        $asset0: defactor(getConfigForScenario(ctx).liquidation.asset.tiny)
+      },
+      betty: { $base: getConfigForScenario(ctx).liquidation.base.tiny }
+    }),
+  },
+  async ({ comet, actors }, context, world) => {
+    const config = getConfigForScenario(context);
+    const { albert, betty } = actors;
+
+    const timeBeforeLiquidation = await timeUntilUnderwater({
+      comet,
+      actor: albert,
+      fudgeFactor: config.liquidationBot.scenario.fudgeFactorLong
+    });
+    
+    while(!(await comet.isLiquidatable(albert.address))) {
+      await comet.accrueAccount(albert.address);
+      await world.increaseTime(timeBeforeLiquidation);
+    }
+
+    const { asset: collateralAsset } = await comet.getAssetInfo(0);
+    const initialCollateral = await comet.collateralBalanceOf(albert.address, collateralAsset);
+
+    expect(await comet.isLiquidatable(albert.address)).to.be.true;
+    expect(initialCollateral).to.be.greaterThan(0);
+
+    const lp0 = await comet.liquidatorPoints(betty.address);
+
+    await betty.absorb({ absorber: betty.address, accounts: [albert.address] });
+
+    const lp1 = await comet.liquidatorPoints(betty.address);
+
+    expect(lp1.numAbsorbs).to.eq(lp0.numAbsorbs + 1);
+    expect(lp1.numAbsorbed.toNumber()).to.eq(lp0.numAbsorbed.toNumber() + 1);
+    expect(await comet.isLiquidatable(albert.address)).to.be.false;
+    expect(await comet.collateralBalanceOf(albert.address, collateralAsset)).to.eq(0);
+
+    const baseBalance = await albert.getCometBaseBalance();
+    expect(Number(baseBalance)).to.be.greaterThanOrEqual(0);
+
+    const numAssets = await comet.numAssets();
+    for (let i = 0; i < numAssets; i++) {
+      const { asset } = await comet.getAssetInfo(i);
+      expect(await comet.collateralBalanceOf(albert.address, asset)).to.eq(0);
+    }
+
+    expect((await comet.userBasic(albert.address)).assetsIn).to.eq(0);
+  }
+);
+
+
+scenario(
+  'Comet#liquidation > multiple liquidators absorb different positions',
+  {
+    tokenBalances: async (ctx) => ({
+      $comet: {
+        $base: getConfigForScenario(ctx).liquidation.base.standard * 2n
+      }
+    }),
+    cometBalances: async (ctx) => ({
+      albert: {
+        $base: -getConfigForScenario(ctx).liquidation.base.standard,
+        $asset0: defactor(getConfigForScenario(ctx).liquidation.asset.standard)
+      },
+      betty: { $base: getConfigForScenario(ctx).liquidation.base.standard },
+      charles: { $base: getConfigForScenario(ctx).liquidation.base.standard }
+    }),
+  },
+  async ({ comet, actors }, context, world) => {
+    const config = getConfigForScenario(context);
+    const { albert, betty, charles } = actors;
+    const numAssets = await comet.numAssets();
+
+    const timeBeforeLiquidation = await timeUntilUnderwater({
+      comet,
+      actor: albert,
+      fudgeFactor: config.liquidationBot.scenario.fudgeFactorShort
+    });
+
+    while(!(await comet.isLiquidatable(albert.address))) {
+      await comet.accrueAccount(albert.address);
+      await world.increaseTime(timeBeforeLiquidation);
+    }
+
+    const lpBetty0 = await comet.liquidatorPoints(betty.address);
+    const lpCharles0 = await comet.liquidatorPoints(charles.address);
+    
+    await betty.absorb({ absorber: betty.address, accounts: [albert.address] });
+    
+    const lpBetty1 = await comet.liquidatorPoints(betty.address);
+    const lpCharles1 = await comet.liquidatorPoints(charles.address);
+
+    expect(lpBetty1.numAbsorbs).to.eq(lpBetty0.numAbsorbs + 1);
+    expect(lpCharles1.numAbsorbs).to.eq(lpCharles0.numAbsorbs);
+    expect(await comet.isLiquidatable(albert.address)).to.be.false;
+
+    for (let i = 0; i < numAssets; i++) {
+      const { asset } = await comet.getAssetInfo(i);
+      const protocolCollateral = await comet.getCollateralReserves(asset);
+      if (i === 0) {
+        expect(protocolCollateral).to.be.greaterThan(0);
+      }
+    }
+  }
 );
\ No newline at end of file
diff --git a/scenario/utils/config/networks.ts b/scenario/utils/config/networks.ts
index ea2a6ef9..3f121a88 100644
--- a/scenario/utils/config/networks.ts
+++ b/scenario/utils/config/networks.ts
@@ -69,6 +69,10 @@ export function applyNetworkOverrides(
       config.transfer.collateralAmount = 10n;
       config.common.amounts.collateral.standard = 10n;
       config.common.amounts.collateral.large = 10n;
+      config.liquidation.base.standard = 100000n;
+      config.liquidation.asset.standard = 10000n;
+      config.liquidationBot.scenario.borrowCapacityUtilizationHigh = 99n;
+      config.liquidationBot.scenario.fudgeFactorShort = 60000n * 100n;
     }
 
     if (deployment === 'weth') {
@@ -82,6 +86,12 @@ export function applyNetworkOverrides(
       config.common.amounts.collateral.standard = 10n;
       config.common.amounts.collateral.large = 10n;
     }
+
+    if (deployment === 'usdbc') {
+      config.liquidation.base.standard = 100n;
+      config.liquidation.asset.standard = 50n;
+      config.liquidationBot.scenario.fudgeFactorLong = 60n * 60n;
+    }
   }
 
   if (network === 'optimism') {
@@ -146,12 +156,10 @@ export function applyNetworkOverrides(
     config.common.amounts.base.large = 30n;
     
     config.transfer.baseAmount = 30n;
-    config.transfer.assetAmount = 500000n; // Drastically increased for transfer tests
-    config.withdraw.alternateAsset = 500000n; // Drastically increased for undercollateralized tests
-    
-    // Withdraw tests: Need collateral to borrow 30n base
+    config.transfer.assetAmount = 500000n;
+    config.withdraw.alternateAsset = 500000n;
     config.withdraw.baseAmount = 30n;
-    config.withdraw.assetAmount = 500000n; // Drastically increased
+    config.withdraw.assetAmount = 500000n;
     config.withdraw.alternateBase = 30n;
     
     config.supply.collateralAmount = 10n;
@@ -162,9 +170,11 @@ export function applyNetworkOverrides(
     
     config.rewards.assetAmount = 1000000n;
     config.rewards.baseAmount = 200n;
-    config.liquidation.base.standard = 150n;
+    config.liquidation.base.standard = 100n;
     config.liquidation.base.medium = 50n;
-    config.liquidation.asset.standard = 5n;
+    config.liquidation.base.tiny = 10n;
+    config.liquidation.asset.standard = 500n;
+    config.liquidation.asset.tiny = 100000000000000n;
     config.bulker.asset.standard = 200n;
     config.bulker.asset.alternate = 200n;
     config.bulker.base.borrow = 30n;
@@ -177,6 +187,7 @@ export function applyNetworkOverrides(
     if (deployment === 'usdc') {
       config.bulker.asset.standard = 200n;
       config.bulker.asset.alternate = 200n;
+      config.assets.maticx.baseBorrowMultiplier = 100n;
     }
 
     if (deployment === 'usdt') {
@@ -195,6 +206,12 @@ export function applyNetworkOverrides(
     config.bulker.asset.alternate = 10n;
   }
 
+  if (network === 'sepolia' && deployment === 'weth') {
+    config.liquidation.base.standard = 1000n;
+    config.liquidation.base.tiny = 10n;
+    config.liquidation.asset.tiny = 100000000000000n;
+  }
+
   if (network === 'linea') {
     if (deployment === 'usdc') {
       config.bulker.asset.standard = 500n;
diff --git a/src/deploy/index.ts b/src/deploy/index.ts
index d4352af8..1de94b35 100644
--- a/src/deploy/index.ts
+++ b/src/deploy/index.ts
@@ -121,6 +121,15 @@ export const WHALES = {
     '0x468c34703F6c648CCf39DBaB11305D17C70ba011', // LBTC whale
     '0x312e67b47A2A29AE200184949093D92369F80B53', // LBTC whale
   ],
+  sepolia: [
+    '0xAec1F48e02Cfb822Be958B68C7957156EB3F0b6e',
+    '0x4d02aF17A29cdA77416A1F60Eae9092BB6d9c026',
+    '0x4243F3D11353aAEB404E31e160EeC362D066637C',
+    '0xa2C64d844c177C814b6F0423b41D8644539f5F58',
+    '0x3846357aAa2b7b6dC7a9037ae51aD71CA46240Ad',
+    '0xD7822b5A41c3655c6C403167F6B8Aa1533620329',
+    '0xB1a7dC6493BF47BE900159364464f72c0B53F252'
+  ],
   polygon: [
     '0xF977814e90dA44bFA03b6295A0616a897441aceC', // USDT whale
     '0x2093b4281990a568c9d588b8bce3bfd7a1557ebd', // WETH whale
@@ -240,6 +249,10 @@ export const WHALES = {
     '0x0cf8ff40a508bdbc39fbe1bb679dcba64e65c7df',
     '0x2ecb08f87f075b5769fe543d0e52e40140575ea7',
     '0x05b0bb3c1c320b280501b86706c3551995bc8571',
+    '0x3230b903e8a5d6e46b5a5028470dd33e7b673722',
+    '0xb32e9a84ae0b55b8ab715e4ac793a61b277bafa3',
+    '0x669527fceb78065e69cc623ab098c7176c0bce1f',
+    '0x3ef3d8ba38ebe18db133cec108f4d14ce00dd9ae',
     '0x392d372f2a51610e9ac5b741379d5631ca9a1c7f', // USDC whale
     '0x245db945c485b68fdc429e4f7085a1761aa4d45d', // WETH whale
   ]
